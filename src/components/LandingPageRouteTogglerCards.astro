---
import TagLineChanger from './TagLineChanger.astro';
import { baseHost } from '../utils/utilities.ts';

type Route = {
    key: string;
    label: string;
    images: string[];
    stops: string[];
    overlay?: string;
    days?: string;
};

const routes: Route[] = [
    {
        key: 'kyoto-kanazawa',
        label: 'Kyoto ↔︎ Kanazawa',
        images: [
            `${baseHost}/assets/img/2024/media/routes/108/358/kyoto-kanazawa-route-examples-Kyoto%20Kanazwa%20Example-medium.jpg`,
        ],
        stops: [
            'Biwako',
            'Hikone',
            'Takashima',
            'Miyama',
            'Kayabuki-no-sato',
            'Ayabe',
            'Maizuru',
            'Takahama',
            'Obama',
            'Wakasa Coast',
            'Mikata Lakes',
            'Fukui',
            'Ono',
            'Kanazawa',
        ],
        overlay: 'top',
        days: '2 ~ 5',
    },
    {
        key: 'nagoya-kanazawa',
        label: 'Nagoya ↔︎ Kanazawa',
        images: [
            `${baseHost}/assets/img/2024/media/routes/113/363/nagoya-kanazawa-example-kyoto-tottori-example-medium.jpg`,
        ],
        stops: [
            'Inuyama',
            'Mino',
            'Yunohara Onsen',
            'Gujyo Hachiman',
            'Lake Kuzuryu',
            'Ono',
            'Katsuyama',
            'Mt. Echizenkabuto',
            'Torigoe',
            'Hakusan',
        ],
        overlay: 'bottom',
        days: '2 ~ 5',
    },
    {
        key: 'kyoto-takayama',
        label: 'Kyoto ↔︎ (Nakasendo) ↔︎ Takayama',
        images: [`${baseHost}/assets/img/2024/media/routes/115/366/kyoto-takayama-kyoto-takayama-example-medium.jpg`],
        stops: [
            'Biwako',
            'Hikone',
            'Sekigahara',
            'Gifu',
            'Toki',
            'Ena',
            'Magome',
            'Tsumago',
            'Nakasendo',
            'Kiso Valley',
            'Kaida Kogen',
            'Ontake',
            'Inuyama',
            'Mino',
            'Gujyu Hachiman',
            'Takasu',
            'Shokawa no Sato',
            'Kiyomi',
        ],
        overlay: 'bottom',
        days: '3 ~ 5',
    },

    {
        key: 'nagoya-takayama',
        label: 'Nagoya ↔︎ (Nakasendo) ↔︎ Takayama',
        images: [`${baseHost}/assets/img/2024/media/routes/114/364/nagoya-takayama-kyoto-tottori-example-medium.jpg`],
        stops: [
            'Iwamura',
            'Ena',
            'Nakasendo',
            'Magome',
            'Tsumago',
            'Nagiso',
            'Gero',
            'Hida Osaka',
            'Inuyama',
            'Mino',
            'Gujyu Hachiman',
            'Takasu',
            'Shokawa no Sato',
            'Kiyomi',
        ],
        overlay: 'bottom',
        days: '2 ~ 4',
    },
    {
        key: 'kyoto-matsumoto',
        label: 'Kyoto ↔︎ Nakasendo ↔︎ Matsumoto',
        images: [
            `${baseHost}/assets/img/2024/media/routes/109/359/kyoto-matsumoto-example-Kyoto-matsumoto-example-medium.jpg`,
        ],
        stops: [
            'Biwako',
            'Nakasendo',
            'Hikone',
            'Sekigahara',
            'Gifu',
            'Toki',
            'Ena',
            'Magome',
            'Tsumago',
            'Kiso Valley',
            'Shiojiri',
            'Azumino',
        ],
        overlay: 'top',
        days: '3 ~ 5',
    },
    {
        key: 'osaka-hiroshima',
        label: 'Osaka ↔︎ Hiroshima',
        images: [
            `${baseHost}/assets/img/2024/media/routes/110/360/osaka-hiroshima-sexample-osaka-hiroshima-sexample-medium.jpg`,
        ],
        stops: [
            'Kobe',
            'Seto Ferry',
            'Tsuyama',
            'Miyoshi',
            'Takamatsu',
            'Zentsuji',
            'Kotohira',
            'Tosa',
            'Matsuyama',
            'Shimanami Kaido',
            'Kure',
        ],
        overlay: 'top',
        days: '3 ~ 5',
    },
    {
        key: 'osaka-matsuyama',
        label: 'Osaka ↔︎ Matsuyama',
        images: [
            `${baseHost}/assets/img/2024/media/routes/111/361/osaka-matsuyama-example-osaka-matsuyama-example-medium.jpg`,
        ],
        stops: ['Kobe', 'Seto Ferry', 'Takamatsu', 'Zentsuji', 'Kotohira', 'Tosa', 'Matsuyama', 'Kure'],
        overlay: 'top',
        days: '3 ~ 5',
    },
    {
        key: 'kyoto-tottori',
        label: 'Kyoto ↔︎ Tottori',
        images: [
            `${baseHost}/assets/img/2024/media/routes/112/362/kyoto-tottori-example-kyoto-tottori-example-medium.jpg`,
        ],
        stops: ['Sanin Train', 'Kameoka', 'Fukuchiyama', 'Wadayama', 'Mt. Hyono', 'Kuwahara', 'Tottori'],
        overlay: 'bottom',
        days: '2 ~ 5',
    },
];
---

<p>
    If you’ve <span class="emph">already planned some major destinations</span> — Kyoto, Tokyo, Kanazawa, Osaka — maybe you’ve
    also looked up the fastest way to get between them. But
    <span class="emph">between those well-known hubs</span> are villages, coastlines, and mountain passes most travelers
    never see.
</p>
<p>
    Below are <span class="emph">just a few examples</span> of how what might otherwise be more travel time between well-known
    destinations can <span class="emph">become a meaningful part of your trip</span> if you <span class="emph"
        >don’t just pass by</span
    >, but take the
    <span class="emph">opportunity to discover</span> what’s in between.
</p>

<div class="carousel">
    <div class="carousel-track">
        {
            routes.map((route) => (
                <div class="slide">
                    <div class="info-item">
                        <>
                            <h2>
                                {route.label}
                                <br />
                                <span class="day-count">{route.days} days</span>
                            </h2>
                        </>
                        <img src={route.images[0]} alt={route.label} class="info-image" />
                        <h2>Some Places In-Between:</h2>
                        <div>
                            {route.stops.map((stop) => (
                                <span class="stop">{stop} | </span>
                            ))}
                        </div>
                        <p class="fineprint">
                            * Routes can follow train lines, allowing for partial rides to fit your schedule.
                        </p>
                    </div>
                </div>
            ))
        }
    </div>
    <div class="dots">
        {routes.map((_, i) => <span class="dot" data-index={i} />)}
    </div>

    <!-- Navigation buttons -->
    <button class="carousel-nav prev">&#8249;&#8249;</button>
    <button class="carousel-nav next">&#8250;&#8250;</button>
</div>

<style lang="scss">
    @use '../styles/global' as *;
    .carousel {
        position: relative;
        overflow: hidden;
        margin-top: 40px;
        @include respond-to(small) {
            //border: 1px solid red;
            padding: 0px;
        }
    }
    .carousel-track {
        display: flex;
        transition: transform 0.5s ease;
        @include respond-to(small) {
            //        border: 1px solid red;
            padding: 0px;
        }
    }
    /* default: 3 across */
    .slide {
        flex: 0 0 calc(100% / 2);
        box-sizing: border-box;
        padding: 0 10px;
        @include respond-to(small) {
            //    border: 1px solid red;
            padding: 0px;
        }
    }

    /* between 768px and 1200px: 2 across */
    @media (max-width: 1200px) and (min-width: 769px) {
        .slide {
            flex: 0 0 50%;
        }
    }

    /* ≤ 768px: 1 across */
    @media (max-width: 768px) {
        .slide {
            flex: 0 0 100%;
        }
    }

    .info-item {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

        @include respond-to(small) {
            padding: 10px;
        }

        .info-image {
            width: 100%;
            height: auto;
            border-radius: 8px;
            object-fit: cover;
            margin-bottom: 20px;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
        }
        .day-count {
            font-size: 0.8em;
        }

        .stop {
            display: inline-block;
            border: 0px solid var(--bs-primary-dark);
            border-bottom: 0px solid var(--bs-primary-dark);
            padding: 2px;
            padding-bottom: 2px;
            margin: 2px;
            border-radius: 0px;
        }
        // .stop:after {
        //     content: '|';
        // }

        .fineprint {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
        }
    }

    .dots {
        display: flex;
        justify-content: center;
        margin-top: 15px;
    }
    .dot {
        width: 8px;
        height: 8px;
        background: #ccc;
        border-radius: 50%;
        margin: 0 5px;
        cursor: pointer;
        transition: background 0.3s;
    }
    .dot.active {
        background: #333;
    }

    .carousel {
        position: relative;
        overflow: hidden;
        margin-top: 40px;
    }
    .carousel-nav {
        position: absolute;
        top: 40%;
        transform: translateY(-50%);
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        border: none;
        padding: 10px;
        font-size: 1.5rem;
        cursor: pointer;
        transition: background-color 0.3s ease;
        border-radius: 5px;
        z-index: 10;
        opacity: 0;
        pointer-events: none; /* Avoid interaction when hidden */
        transition:
            opacity 0.3s ease,
            transform 0.3s ease;
    }

    /* Arrows become visible on hover over the carousel */
    .carousel:hover .carousel-nav {
        opacity: 1;
        pointer-events: auto; /* Enable interaction on hover */
    }

    /* Ensure visibility and interaction on all screens */
    .carousel-nav.prev {
        left: 10px;
    }

    .carousel-nav.next {
        right: 10px;
    }

    /* Make sure the carousel arrows are positioned well on mobile screens */
    @media (max-width: 768px) {
        .carousel-nav {
            opacity: 1; /* Ensure the arrows are always visible on mobile */
            pointer-events: auto; /* Enable interaction without hover */
            top: 35%;
        }

        /* Make the arrows slightly larger on mobile for better usability */
        .carousel-nav {
            font-size: 2rem;
            padding: 12px;
        }
    }
</style>
<script is:inline>
    document.addEventListener('DOMContentLoaded', () => {
        const track = document.querySelector('.carousel-track');
        const dots = Array.from(document.querySelectorAll('.dot'));
        const carousel = document.querySelector('.carousel');
        const prevButton = document.querySelector('.carousel-nav.prev');
        const nextButton = document.querySelector('.carousel-nav.next');
        let currentDot = 0;
        let isMovingNext = false;

        // Set default and manual control delays
        let defaultScrollDelay = 6000; // Default to 6 seconds
        let manualControlDelay = 60000; // 60 seconds after manual control

        let autoScrollInterval; // Will store the interval reference for clearing when needed

        // Function to get the width of each slide
        function getSlideWidth() {
            return track.firstElementChild.getBoundingClientRect().width;
        }

        // Set active dot
        function setActiveDot(i) {
            dots.forEach((d, idx) => d.classList.toggle('active', idx === i));
            currentDot = i;
        }

        // Move carousel to next slide
        function moveNext() {
            isMovingNext = true;
            const w = getSlideWidth();
            track.style.transition = 'transform 0.5s ease';
            track.style.transform = `translateX(-${w}px)`;
        }

        // Move carousel to previous slide
        function movePrev() {
            const w = getSlideWidth();
            track.style.transition = 'none';
            track.insertBefore(track.lastElementChild, track.firstElementChild);
            track.style.transform = `translateX(-${w}px)`;
            requestAnimationFrame(() => {
                track.style.transition = 'transform 0.5s ease';
                track.style.transform = 'translateX(0)';
            });
            const prevDot = (currentDot - 1 + dots.length) % dots.length;
            setActiveDot(prevDot);
        }

        // When forward animation ends, update the carousel
        track.addEventListener('transitionend', () => {
            if (!isMovingNext) return;
            isMovingNext = false;

            track.style.transition = 'none';
            track.style.transform = 'translateX(0)';
            track.appendChild(track.firstElementChild);

            const nextDot = (currentDot + 1) % dots.length;
            setActiveDot(nextDot);
        });

        // Button click events to move next or previous
        nextButton.addEventListener('click', () => {
            moveNext();
            setManualControl();
        });

        prevButton.addEventListener('click', () => {
            movePrev();
            setManualControl();
        });

        // Start auto-scroll with the specified delay
        function startAutoScroll(interval) {
            // Ensure any existing interval is cleared before starting a new one
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
            }
            autoScrollInterval = setInterval(moveNext, interval);
        }

        // Pause the auto-scroll
        function pauseAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval); // Simply clear the interval when paused
            }
        }

        // Set manual control for the scroll and adjust the delay to 60 seconds
        function setManualControl() {
            pauseAutoScroll(); // Pause auto-scroll immediately
            // After the manual interaction, wait for 60 seconds before resuming
            setTimeout(() => {
                startAutoScroll(defaultScrollDelay); // Resumes auto-scroll every 6 seconds after delay
            }, manualControlDelay); // Delay before resuming
        }

        // Dot clicks
        dots.forEach((dot, i) => {
            dot.addEventListener('click', () => {
                const diff = (i - currentDot + dots.length) % dots.length;
                if (diff === 0) return;
                if (diff <= dots.length / 2) {
                    for (let k = 0; k < diff; k++) moveNext();
                } else {
                    for (let k = 0; k < dots.length - diff; k++) movePrev();
                }
                setManualControl(); // Trigger manual control after clicking a dot
            });
        });

        // Swipe support for touch events
        let startX = 0;
        carousel.addEventListener('touchstart', (e) => {
            startX = e.changedTouches[0].clientX;
        });
        carousel.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const dx = endX - startX;
            if (dx > 50) {
                movePrev();
            } else if (dx < -50) {
                moveNext();
            }
            setManualControl(); // Trigger manual control after swipe
        });

        // Set the first dot as active
        setActiveDot(0);

        // Start the auto-scroll initially with default 6-second interval
        startAutoScroll(defaultScrollDelay);
    });
</script>

<!-- 
<script is:inline>
    document.addEventListener('DOMContentLoaded', () => {
        const track = document.querySelector('.carousel-track');
        const dots = Array.from(document.querySelectorAll('.dot'));
        const carousel = document.querySelector('.carousel');
        let currentDot = 0;
        let isMovingNext = false;

        // get a fresh slide width (adapts to 1/2/3‑across)
        function getSlideWidth() {
            return track.firstElementChild.getBoundingClientRect().width;
        }

        // highlight dot
        function setActiveDot(i) {
            dots.forEach((d, idx) => d.classList.toggle('active', idx === i));
            currentDot = i;
        }

        // forward: slide left, then on transitionend append first slide
        function moveNext() {
            isMovingNext = true;
            const w = getSlideWidth();
            track.style.transition = 'transform 0.5s ease';
            track.style.transform = `translateX(-${w}px)`;
        }

        // backward: prepend last slide, jump left, then animate back to zero
        function movePrev() {
            const w = getSlideWidth();
            track.style.transition = 'none';
            track.insertBefore(track.lastElementChild, track.firstElementChild);
            track.style.transform = `translateX(-${w}px)`;
            requestAnimationFrame(() => {
                track.style.transition = 'transform 0.5s ease';
                track.style.transform = 'translateX(0)';
            });
            // update dot immediately
            const prevDot = (currentDot - 1 + dots.length) % dots.length;
            setActiveDot(prevDot);
        }

        // when forward animation ends, do the reorder & update dot
        track.addEventListener('transitionend', () => {
            if (!isMovingNext) return;
            isMovingNext = false;

            // strip transition, reset transform, append first
            track.style.transition = 'none';
            track.style.transform = 'translateX(0)';
            track.appendChild(track.firstElementChild);

            // advance dot
            const nextDot = (currentDot + 1) % dots.length;
            setActiveDot(nextDot);
        });

        // auto‑play every 6s
        setInterval(moveNext, 6000);

        // dot clicks
        dots.forEach((dot, i) => {
            dot.addEventListener('click', () => {
                // calculate distance to shift
                const diff = (i - currentDot + dots.length) % dots.length;
                if (diff === 0) return;
                if (diff <= dots.length / 2) {
                    // move forward diff times
                    for (let k = 0; k < diff; k++) moveNext();
                } else {
                    // move backward dots.length - diff times
                    for (let k = 0; k < dots.length - diff; k++) movePrev();
                }
            });
        });

        // swipe support
        let startX = 0;
        carousel.addEventListener('touchstart', (e) => {
            startX = e.changedTouches[0].clientX;
        });
        carousel.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const dx = endX - startX;
            if (dx > 50) {
                movePrev();
            } else if (dx < -50) {
                moveNext();
            }
        });

        // initial dot
        setActiveDot(0);
    });
</script> -->
